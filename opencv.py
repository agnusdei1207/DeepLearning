# -*- coding: utf-8 -*-
"""openCV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nElMNK_nqiQoIOmSfDWTL86_xRDmIWUs

- opencv -python : main module
- opencv -contrib-python : retra module
"""

!pip install opencv -python

"""### OpenCV
- 영상 / 이미지 전처리
- 사전학습 된 모델 제공
- C언어 기반으로 인텔에서 시작된 프로젝트
- opencv -python : 기존 opencv를 python으로 감싼 모듈
- 언어는 python 이지만 실제로는 C언어로 작동
- numpy 타입 지원
"""

# openCV 라이브러리
import cv2

# 이미지 로딩
img  = cv2.imread("./data/hamster.jpg",  # 읽을 이미지 경로
                 cv2.IMREAD_COLOR) # 컬러사진으로 읽겠다
img = cv2.resize(img,(1000,1000), interpolation = cv2.INTER_CUBIC) # 사진 축소 / interpolation : 작은 사진의 크기를 늘렸을 때 어떻게 빈공간을 메울래?
print(img)
print(f"이미지 차원 : {img.shape}")

cv2.imshow("ham~", # 보여줄 사진 이름
         img) # 실제로 보여줄 이미지 데이터
cv2.waitKey(0) # waitKey(0) : 사용자가 키를 입력할 때까지 무한정 기다려라  / milli second / Java 의 Scanner와 같은 원리
cv2.destroyAllWindows() # 모든 창 제거

# 이미지 로딩 흑백
img  = cv2.imread("./data/hamster.jpg",  # 읽을 이미지 경로
                 cv2.IMREAD_GRAYSCALE) # 컬러사진으로 읽겠다
img = cv2.resize(img,(1000,1000), interpolation = cv2.INTER_CUBIC) # 사진 축소 / interpolation : 작은 사진의 크기를 늘렸을 때 어떻게 빈공간을 메울래?
print(img)
print(f"이미지 차원 : {img.shape}")

cv2.imshow("ham~", # 보여줄 사진 이름
         img) # 실제로 보여줄 이미지 데이터
cv2.waitKey(0) # waitKey(0) : 사용자가 키를 입력할 때까지 무한정 기다려라  / milli second / Java 의 Scanner와 같은 원리
cv2.destroyAllWindows() # 모든 창 제거

import matplotlib.pyplot as plt

img = cv2.imread("./data/hamster.jpg", cv2.IMREAD_COLOR)

# opencv 와 matplotlib 색상체계가 다르다
# opencv > BGR
# plt > RGB

img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.imshow(img_rgb)
plt.title("ham")
plt.show()

# 영상 로딩
try:
    print("영상 로딩을 시작합니다")
    my_cam = cv2.VideoCapture('./data/chopin_16.mp4')
except:
    print("파일 로딩 실패...")

# b : 영상을 읽었는지? Ture or False
# f : FPS 프레임 정보, numpy 타입
b, f = my_cam.read() # 영상 FPS 를 읽음

print(b, f)

if b:
    cv2.imshow("title", f)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

# 영상, 이미지 작업 시 반드시 release()를 사용해서 메모리를 깔끔하게 유지하기
my_cam.release() # 메모리에 적재된 상태를 해제 하기 == close()

try:
    print("영상 로딩을 시작합니다")
    my_cam = cv2.VideoCapture('./data/chopin_16.mp4')
except:
    print("파일 로딩 실패...")
    
while(True):
    b, frame = my_cam.read() # 한 프레임씩 다 읽어오기
    
    if b == False:
        break
    else:
        frame = cv2.resize(frame,(500,300),interpolation = cv2.INTER_CUBIC)
        cv2.imshow('result', frame)
    
    k = cv2.waitKey(33) # 33ms 대기 : 1초에 30fps 를 미리 읽어오기 위해 살짝씩 딜레이를 걸어둔다.
    
    if k == 27: # ese == 27 
        break

cv2.destroyAllWindows()
my_cam.release()

"""### 이진 이미지 만들기
1. 컬러 이미지 : RGB
2. 흑백 이미지 : Gray : 0~255 흑백 픽셀 값으로 구성
3. 이진 이미지 : 0 또는 255 / 0 또는 1 활용
"""

img = cv2.imread("./data/hamster.jpg", cv2.IMREAD_GRAYSCALE)

#데이터 이진화 : OCR 손글씨에 주로 활용
_ , img = cv2.threshold(img, # 변화시킬 이미지
                       100, # 변화줄 이진 분류 임계치 190 이상, 미만  / 임계치가 매우 중요!
                       255, # 임계치보다 클 경우 변화된 후 값
                       cv2.THRESH_BINARY)

plt.imshow(img, cmap="gray")
plt.xticks([]) # 눈금 제거
plt.yticks([]) 
plt.show()

"""### 외각선 검출
1. pixel 의 밝기가 급격하게 변화하는 순간을 포착하여 외각선으로 인식하는 알고리즘
2. 밝기 변화의 기울기 값(w)를 계산하는 알고리즘 (Canny)
"""

img = cv2.imread("./data/hamster.jpg", cv2.IMREAD_GRAYSCALE)

# 외각선 검출
# 최소, 최대 임계값
edge = cv2.Canny(img, 150, 250)

plt.imshow(edge, cmap="gray")
plt.xticks([]) # 눈금 제거
plt.yticks([]) 
plt.show()

"""### 데이터 종류에 따른 이미지 처리 방법 
1.  픽셀 기반 처리 : 사진에 들어있는 RGB 픽셀 정보를 직접 처리
2. 영역 기반 처리 : 픽셀 정보를 그룹화 해서 처리
    - ex) 이미지 생성, 그려주기 >> 픽셀값의 확률 분포
3. 주파수 기반 처리 : 픽셀 정보를 주파수로 변환하여 처리
    - 푸리에 변환 fourier
    - 주파수 : 파동의 떨림을 표현
    - 밝기 변화가 크면 고주파 / 밝기 변화가 작으면 저주파
    - ex) cctv 움직이지 않은 물체 저주파 / 움직이는 물체 고주파
"""

# 픽셀기반 처리

img = cv2.imread("./data/hamster.jpg", cv2.IMREAD_COLOR)

p1 = img[50,50] # 50, 50에 위치한 픽셀 검출 / BGR
print(p1) # BGR
# 이미지 처리 시 왼쪽상단부터 좌표 (0,0) 행, 열
print(p1.dtype)
print(img.shape)

# ROI 이미지 관심영역 Region of Image

roi_img = img[0:50, 100:200] # 행, 열

cv2.imshow('ROI', roi_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 그리기 함수
1. cv2.line(이미지, 시작점 좌표, 끝점 좌표, 색상, 두께) : 선 그리기
2. cv2.circle(이미지, 중심 좌표, 반지름, 색상, 두께) : 원 그리기
3. cv2.rectangle(이미지, 좌상단 좌표, 우하단 좌표, 색상, 두께) : 사각형 그리기
4. cv2.eilipse(이미지, 중심좌표, 장축길이/단축길이, 시작각도, 끝각도, 색상, 두께) : 타원그리기
5. cv2.putText(이미지, 출력내용, 시작좌표, 폰트, 크기, 색상, 굵기) : 텍스트 출력
"""

img = cv2.imread("./data/hamster.jpg", cv2.IMREAD_COLOR)
# (좌상단: 우상단), (좌하단, 우하단), (RGB 색상), 두께 = 3  / 가로 세로 
img_result = cv2.rectangle(img, (40,30),(200,130),(255,0,0),3)
img_result2 = cv2.putText(img, "hamster", (70,20), cv2.FONT_HERSHEY_COMPLEX, 1, (200,0,0),2)

cv2.imshow('ROI', img_result)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 얼굴 검출
- 사각형 커널을 사용해서 계산
- 검은색 영역과  흰색 영역 픽셀 합의 차이를 계산

1. ![KakaoTalk_20220111_115231067.png](attachment:KakaoTalk_20220111_115231067.png)

2. ![KakaoTalk_20220111_115226012.png](attachment:KakaoTalk_20220111_115226012.png)
"""

cv2.data.haarcascades

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+'haarcascade_frontalface_default.xml') # 정면얼굴 기본값 xml파일
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+'haarcascade_eye.xml') # 눈 기본값 xml파일

# 얼굴사진 로딩
face_img = cv2.imread("./data/aaa.jpg")


# 얼굴 검출 detectMulitScale(이미지, 커널 스케일, 최소 이웃값)
# 커널 스케일 : 검출이 될 때까지 커널의 크기를 n배씩 키운다
# 최소 이웃값 : 스케일이 최소 n개 겹쳐야 얼굴로 인식
faces = face_cascade.detectMultiScale(face_img,1.3,5)
# 눈 검출
eyes = eye_cascade.detectMultiScale(face_img,1.2,4)

print(len(eyes))
print(len(faces))

for(x,y,w,h) in faces:
    # 얼굴 영역 사각형 그리기
    # (좌상단: 우상단), (좌하단, 우하단), (RGB 색상), 두께 = 3  / 가로 세로
    cv2.rectangle(face_img,(x,y),(x+w,y+h),(255,0,0),3)
    
for(x,y,w,h) in eyes:
    # 눈 영역 사각형 그리기
    cv2.rectangle(face_img,(x,y),(x+w,y+h),(0,0,255),3)

cv2.imshow('face',face_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

